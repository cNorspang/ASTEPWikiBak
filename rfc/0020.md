---
title: RFC 0020
description: Transportation Network Model
published: true
date: 2021-11-11T13:44:57.288Z
tags: cooperation, transportation, model
editor: markdown
---

# 0020 - Transportation Network Model
**Accepted**

*Proposed: 23. Sep. 2021* | *state: 29. Sep. 2021* | *Last Modification: 10. Nov. 2021*

## Summary

A general model for a traffic network, in which multiple microservices can be connected to it in a specified pipeline, where each microservices has the model as an I/O.
Is primarily structured around a standardised schema which describes the model, and a description of the different types of microservices which can be developed to use the schema.
The Transporation Network is basically a weighted graph, where each node and edge has a weight and some data connected.

## Motivation

A general model for a Transporation Network makes it possible for multiple groups to work together with a unified objective, while still maintaining the autonomous development that each group has.
Each microservice enhances the Transportation Network by itself, while the new microservice can be used in conjunction with all the other microservices, making it highly scaleable.
A concrete example would be a microservice that makes the model with data from the database, then three microservices give different weights depending on environmental driving, traffic and (only) shortest distance, which then by the end is fed into a microservice that finds the shortest path based on weights.

## Details

### The Objective
The objective is to describe a JSON schema which can be used as I/O of all microservices working with Transportation Network Model.

To do this, 7 different topics together form the basis of the Transportation Network Model, which is:
- [Component Diagram](#component-diagram)
- [The Format](#the-format)
- [Types of Microservices](#types-of-microservices)
- [The data Attribute](#the-data-attribute)
- [Error Handling](#error-handling)
- [Integrating a valid service](#integrating-a-valid-service)
- [Example](#example)

### Component Diagram
current implementation:
![components_current.png](/rfc/0020/components_current.png)
future design
![components.png](/rfc/0020/components.png)
A quick run through the diagram:
The user selects a starting point, a destination and some weighters in the UI.
The selected microservices are requested to define what data they need.(not implemented)
The creator is called to get data about the area specified by the user from the database and convert it into TNM.
A copy of this TNM is passed to the microservices, each microservice adapts the TNM into some internal representation and does its thing, adapts the data back to TNM format and returns the annotated TNM to the controller.
When all weighter microservices have returned their results to the controller, it passes the annotated TNM models to the combiner service that returns one TNM model to the controler.
This TNM is passed to the router that calculates the best route based on the annotated weights on the TNM.
The selected route and the area is sent to the UI creator which returns UI elements, theese elements are sent to the controller which passes them to the UI.

### The Format
The format of the Transportation Network Model is a JSON model suited for being sent and received via http requests, controlled by the UI Controller. The Trafic Network Model (TNM) is the base model that all microservices should use when handling data.
```json
all values are examples, no value should be seen as static.

GET / info
output: {
  	"meta_data": {
    		"max_length": 1320,
        "min_length": 32,
        "max_slope": 25.0,
        "min_slope": -16.3,
        "max_set_max_speed": 130,
        "min_recommended_speed": 20,
        "max_mean_speed": 132,
        "min_mean_speed": 24,
        "max_daily_year": 300000,
        "min_daily_year": 14,
        "max_daily_july": 323000,
        "min_daily_july": 17,
        "max_daily_trucks": 542,
        "min_daily_trucks": 0,
        
  	},
		"vehicle":{
  			"id":0,                       (int)
        "data":{}
    },
    "nodes": {																		  
    		"3302":{
        		"node_id": 3302,							 	(int)
        		"weight":0.0                   	(decimal, 0-1)
        		"data":{
            		"lon": 42.1,								(decimal)
                "lat": 32.3,								(decimal)
                "country": "DK",						(string)
                "municipality": "Aalborg",	(string)
                "mun_border": true,					(bool)
                "type": "driveway", 				(string)
                "signal_control": true			(bool)
            }                          
        		"edges":{												 
        				"1":{
            				"edge_id": 1, 
                		"weight": 0.2,
                		"data":{
                    		"length": 132,						(integer)
                        "slope": 10.4,						(decimal)
                        "type": "ramp",						(string)
                        "type_max_speed": 80,			(integer)
                        "set_max_speed": 70,			(integer)
                        "recommended_speed": 50,	(integer)
                        "mean_speed": 65,					(integer)
                        "daily_year": 142363,			(integer)
                        "daily_july": 258139,			(integer)
                        "daily_trucks": 374,			(integer)
                        "daily_10_axle":102,			(integer)
                        "fuel_station": false,		(boolean)
                        "max_axle_load": 12.4,		(decimal)
                        "max_height": 5.4,				(decimal)
                        "max_length": 7.3,				(decimal)
                        "max_weight": 3.4					(decimal)
                    }
            		}, 
                ...
            }
        },
        ...
    }
}

```

In the format, the parenthesis describes if the attribute is constrained to be some specific value or should be inside some range.
Also, the syntax ... signifies that the list can contain an indefinete amount of objects following the given schema.


This design has been chosen, since then all nodes contains each of its edges going outward (the right side of the road), whereas all ingoing edges (left side of the road) are contained in other nodes. This reduces the duplication of data, and also takes into account that sometimes the right side of the road is filled by traffic, while the other side of the road might be completely free.

The details of what the other different attributes mean, is described in the following topics.
- `error_list` is described in [Error Handling](#error-handling)
- `meta_data` and `data` is described in [The data Attribute](#the-data-attribute)
- `weight` is described in [Normalization of Weights](#normalization-of-weights)



In the format, the parenthesis describes if the attribute is constrained to be some specific value or should be inside some range.
Also, the syntax ... signifies that the list can contain an indefinete amount of objects following the given schema.

The `vehicle` object signifies the object being simulated to be on the road.

The `nodes` list/dictionary is a dictionary/list<node> of individual nodes, signifying unique GPS coordinates on a map, typically intersections where roads meet. Each node contains an edges dictionary/list<edge> of directed edges leaving the node. A node represents a junction, the node weight represents the notion that a node can cause a delay when travelling over it. (A node could be a traffic light junction).
```json
Node = {
            "node_id": 1,
            "weight": 1,
            "data":{
                "longitude" : 12.6236419221083,
                "latitude" : 12.6236419221083
            },
            "edges": {3245:{edge_id:3245 ....}}
        }
```

The `edges` is a list<edge> of edges. An edge represents a road segment from a node to a node. Thus the edges list represents all roads leaving the node. 
Note that the from_node is implicitly the node that contains the edge, and the to_node_id is the endpoint of the roadsegment. 
```json
Edge = {
            "edge_id":9,  
            "to_node_id": 2,
            "weight": 1,
            "data":{
                "distance": 45.83,
                "road_name": "Ã…stvej",                        
                "road_type": "residential",
                "maxs_peed": 60
            }
        }
```

Data: The `data` field contained in `node`, `edge`, `vehicle` can hold any kind of data, thus it can be used if a microservice handles data specific to a certain microservice. the examples above places locational data and speed limits in the data field. If a microservice wants to handle new kinds of date, they need to update the [data_model.py](#data-model-file) with a conversionScheme function.
  
### Types of Microservices
Each microservice that wants to abide to the Transport Network Model interface has to uphold some general criteria and some specific criteria, based on which type of microservice it is, abiding by the rule that a microservice must do only one thing, but do it well.
  
An overview of all presently implemented TNM Microservices can be found [here](/services#transportation-network-rfc-0020)
  
The (current) different types of microservices are.
- `Creator`:
  The Creator handles database access, it converts database data into the TNM model. It is the only microservice in the whole of TNM which there can be exactly only one, namely [TNM_Creator_Genesis](/services/TNM_Creator_Genesis).
- `Trimmer`:
  
- `Expector`:
  An Expector is a microservice that takes a TNM model in, and gives the exact same model out, only changing null values in the model to some expected value. The output should be redirected to a Combiner by the Controller.
  
- `Weighter`:
  A Weighter is a microservice that takes a TNM model in, and gives the exact same model out, only changing the weights on the nodes and edges. The output should be redirected to a Combiner by the Controller.
  
- `Combiner`:
  A Combiner is a microservice that combines multiple TNMs into one, and normalizes the weights while keeping the priorizations made by the user. A concrete implementation of this is the [TNMCombinerWeightCombiner2021](https://daisy-git.cs.aau.dk/astep-2021/astep-6) service on the gitLab server.
  
- `Router`:
  

At the end of this section, there is detailed how new types of microservices can be added to the UI controller which calls the different microservices.

#### General Criteria
These are the criteria all valid microservices must use, who wants to use this Transportation Network Model.
- Each microservice must implement an Adapter inside the service, which has two functions, to_json(internal_rep) and from_json(model_schema) (naming may also be camelCase or PascalCase dependent on implementation language).
- from_json(model_schema) should be the first process run by the service, which deserializes the model_schema, which it receives from the Controller when called, into some internal representation (internal_rep)
- to_json() should be the last process run by the service before returning the model back to the Controller, which seriailizes the internal representation into a valid Transportation Network Model schema.
- The internal representation may be as different and chaotic as necessary, but when serialized into a valid schema, all restrictions presented in [The Format](#the-format) and [Combination of Weights](#combination-of-weights) must be upheld.

  
### The data Attribute
The data attribute is meant to hold information that the different specific microservices need. But to accomodate limitations in C# it will be not be a dynamic field but constant, so all microservices wil recieve excactly the same data_model object, the different microservices must decide on what data they need, and add the desired data, that is not allready pressent, to the data field. When doing this make sure to update the data_model and create the appropriate ConversionScheme function to convert the specific database dataRows into the TNM. [General Criteria](#general-criteria)

  
  

### Error Handling
Currently, there is a *strict* error handling, Controller Service driven.
What this means is that any microservice in the pipeline is expected to raise an exception when it sees an error, and the Controller is expected to catch it and create a proper response to the end user.

### Integrating a valid service
Too add a new weighter or router service to the transportation pipeline the controller microservice has to be accessed. This is done thorugh the [GitLab](https://daisy-git.cs.aau.dk/astep-2021/group-11/tnm-controller) of the controller microservice. In the function called `SetupServiceObjects()` inside the `service.py` file four lists are maintained of all the weighter and router services currently accesable for the controller. To integrate a new service add the name and URL of said service to either the weighter or router lists depending on the service. After this has been done and pushed onto the master branch where it hopefully passes the pipeline, you should be able to see your newly added service in the dropdown menues of the TNM service on aSTEP.
Below a code snippet with the four mentioned lists can be seen:
```python
  weighterNames = ["Time To Traverse Road", "Traffic On Road", "Fuel consumption"]	
	weighterURLs = ["URL1", "URL2", "URL3"]
	routerNames = ["A* Router", "Greedy Router", "Deep Q Network Router"]
	routerURLs = ["URL4", "URL5", "URL6"]
``` 
  
## Example
This example shows a star junction.
![star_junction.png](/star_junction.png)

the corresponding TNM model:
```json
{
    "error_list": [],
    "meta_data": {
        "last_service": "Creator",
        "priority": 0
    },
    "vehicle":{
        "id":0,
        "data":{}
    },
    "nodes": {
       "0": {
            "node_id": 0,
            "node_weight": 0.0,
            "data":{
                "longitude": 40,
                "latitude": 50
            },
            "edges": {
                "0":{
                    "edge_id": 0,
                    "to_node_id": 1,
                    "edge_weight": 0.0,
                    "data":{
                        "road_name": "Street A",
                        "distance": 100,
                        "max_speed": 130,
                        "road_type": "highway"
                    }
                },
               "1": {
                    "edge_id": 1,
                    "to_node_id": 2,
                    "edge_weight": 0.0,
                    "data":{
                        "road_name": "Street B",
                        "distance": 200,
                        "max_speed": 80,
                        "road_type": "residential"

                    }
                },
                "2":{
                    "edge_id": 2,
                    "to_node_id": 3,
                    "edge_weight": 0.0,
                    "data":{
                        "road_name": "Street C",
                        "distance": 300,
                        "max_speed": 50,
                        "road_type": "city"

                    }
                }
            }
        },
        "1":{
            "node_id": 1,
            "node_weight": 0.0,
            "data":{
                "longitude": 41,
                "latitude": 51
            },
            "edges": {
            
               "5": {
                    "edge_id": 5,
                    "to_node_id": 0,
                    "edge_weight": 0.0,
                    "data":{
                        "road_name": "Street A",
                        "distance": 100,
                        "max_speed": 130,
                        "road_type": "highway"

                    }
                }
                
            }
        },
        "2":{
            "node_id": 2,
            "node_weight": 0.0,
            "data":{
                "longitude": 42,
                "latitude": 52
            },
            "edges": {
                
                "4":{
                    "edge_id": 4,
                    "to_node_id": 0,
                    "edge_weight": 0.0,
                    "data":{
                        "road_name": "Street B",
                        "distance": 200,
                        "max_speed": 80,
                        "road_type": "residential"

                    }
                }
                
            }
        },
        "3":{
            "node_id": 3,
            "node_weight": 0.0,
            "data":{
                "longitude": 43,
                "latitude": 53
            },
            "edges": {
                "3":{
                    "edge_id": 3,
                    "to_node_id": 0,
                    "edge_weight": 0.0,
                    "data":{
                        "road_name": "Street C",
                        "distance": 300,
                        "max_speed": 50,
                        "road_type": "city"

                    }
                }
            }
        }
    }
}
```
  
## Alternatives

TO DO