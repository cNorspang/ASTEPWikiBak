---
title: RFC 0020
description: Transportation Network Model
published: true
date: 2021-11-11T09:16:18.506Z
tags: cooperation, transportation, model
editor: markdown
---

# 0020 - Transportation Network Model
**Accepted**

*Proposed: 23. Sep. 2021* | *state: 29. Sep. 2021* | *Last Modification: 10. Nov. 2021*

## Summary

A general model for a traffic network, in which multiple microservices can be connected to it in a specified pipeline, where each microservices has the model as an I/O.
Is primarily structured around a standardised schema which describes the model, and a description of the different types of microservices which can be developed to use the schema.
The Transporation Network is basically a weighted graph, where each node and edge has a weight and some data connected.

## Motivation

A general model for a Transporation Network makes it possible for multiple groups to work together with a unified objective, while still maintaining the autonomous development that each group has.
Each microservice enhances the Transportation Network by itself, while the new microservice can be used in conjunction with all the other microservices, making it highly scaleable.
A concrete example would be a microservice that makes the model with data from the database, then three microservices give different weights depending on environmental driving, traffic and (only) shortest distance, which then by the end is fed into a microservice that finds the shortest path based on weights.

## Details

### The Objective
The objective is to describe a JSON schema which can be used as I/O of all microservices working with Transportation Network Model.

To do this, 8 different topics together form the basis of the Transportation Network Model, which is:
- [Component Diagram](#component-diagram)
- [The Format](#the-format)
- [Combination of Weights](#combination-of-weights)
- [Types of Microservices](#types-of-microservices)
- [The data Attribute](#the-data-attribute)
- [Error Handling](#error-handling)
- [Integrating a valid service](#integrating-a-valid-service)
- [Example](#example)

### Component Diagram
![components.png](/rfc/0020/components.png)
INSERT DIAGRAM WHEN MADE AND GIVE OVERARCHING DESCRIPTION OF WORKFLOW

### The Format
The format of the Transportation Network Model is a JSON model suited for being sent and received via http requests, controlled by the UI Controller. The Trafic Network Model (TNM) is the base model that all microservices should use when handling data.
```json
GET / info
output: {
       "meta_data": {
                    		
                    },
          "vehicle":{
                            "id":0,                       (int)
                            "data":{}
                      },
          "nodes": {																		  
          					3302:{node_id: 3302, 								 (int)
                    			weight:0.0                     (0-1)
                          data:{}                          
                          edges:{												 
                          			   1:{
                                   		edge_id: 1, 
                                   		weight: 0.2,
                                      data:{}
                                   }, 
                          			   ...
                          },
                    			...
                     }
              }

```

In the format, the parenthesis describes if the attribute is constrained to be some specific value or should be inside some range.
Also, the syntax ... signifies that the list can contain an indefinete amount of objects following the given schema.


This design has been chosen, since then all nodes contains each of its edges going outward (the right side of the road), whereas all ingoing edges (roads) are contained in other nodes. This reduces the duplication of data, and also takes into account that sometimes the right side of the road is filled by traffic, while the other side of the road might be completely free.

The details of what the other different attributes mean, is described in the following topics.
- `error_list` is described in [Error Handling](#error-handling)
- `meta_data` and `data` is described in [The data Attribute](#the-data-attribute)
- `weight` is described in [Normalization of Weights](#normalization-of-weights)



In the format, the parenthesis describes if the attribute is constrained to be some specific value or should be inside some range.
Also, the syntax ... signifies that the list can contain an indefinete amount of objects following the given schema.

The `vehicle` object signifies the object being simulated to be on the road.

The `nodes` list/dictionary is a dictionary/list<node> of individual nodes, signifying unique GPS coordinates on a map, typically intersections where roads meet. Each node contains an edges dictionary/list<edge> of directed edges leaving the node. A node represents a junction, the node weight represents the notion that a node can cause a delay when travelling over it. (A node could be a traffic light junction).
```json
Node = {
            "node_id": 1,
            "weight": 1,
            "data":{
                "longitude" : 12.6236419221083,
                "latitude" : 12.6236419221083
            },
            "edges": {3245:{edge_id:3245 ....}}
        }
```

The `edges` is a list<edge> of edges. An edge represents a road segment from a node to a node. Thus the edges list represents all roads leaving the node. 
Note that the from_node is implicitly the node that contains the edge, and the to_node_id is the endpoint of the roadsegment. 
```json
Edge = {
            "edge_id":9,  
            "to_node_id": 2,
            "weight": 1,
            "data":{
                "distance": 45.83,
                "road_name": "Ã…stvej",                        
                "road_type": "residential",
                "maxs_peed": 60
            }
        }
```

Data: The `data` field contained in `node`, `edge`, `vehicle` can hold any kind of data, thus it can be used if a microservice handles data specific to a certain microservice. the examples above places locational data and speed limits in the data field. If a microservice wants to handle new kinds of date, they need to update the [data_model.py](#data-model-file) with a conversionScheme function.


### Combination of Weights
  TODO
  
### Types of Microservices
Each microservice that wants to abide to the Transport Network Model interface has to uphold some general criteria and some specific criteria, based on which type of microservice it is, abiding by the rule that a microservice must do only one thing, but do it well.

The (current) different types of microservices are.
- `Creator`:
  The Creator handles database access, it converts database data into the TNM model. To gain database access, you will need to have the `database.ini` file in the creator src repo, this file holds the credentials to the database and should be kept in the gitignore file. 
  The Creator contains the definition of the `data_model.py`(TNM) , and an `adaptor.py` file that handles the conversion from database rows to the TNM. Whenever new data is introduced to any microservice it is important to update the data_model.py to include node, edge and connversionScheme definitions that can handle the new data see [data_model.py](#data-model-file)  
- `Trimmer`:
  
- `Expector`:
  
- `Weighter`:
  
- `Combiner`:
  A Combiner is a microservice that combines multiple TNMs into one, and normalizes the weights while keeping the priorizations made by the user. A concrete implementation of this is the [TNMCombinerWeightCombiner2021](https://daisy-git.cs.aau.dk/astep-2021/astep-6) service on the gitLab server.
  
- `Router`:
  

At the end of this section, there is detailed how new types of microservices can be added to the UI controller which calls the different microservices.

#### General Criteria
These are the criteria all valid microservices must use, who wants to use this Transportation Network Model.
- Each microservice must implement an Adapter inside the service, which has two functions, to_json(internal_rep) and from_json(model_schema) (naming may also be camelCase or PascalCase dependent on implementation language).
- from_json(model_schema) should be the first process run by the service, which deserializes the model_schema, which it receives from the UI Controller when called, into some internal representation (internal_rep)
- to_json() should be the last process run by the service before returning the model back to the UI Controller, which seriailizes the internal representation into a valid Transportation Network Model schema.
- The internal representation may be as different and chaotic as necessary, but when serialized into a valid schema, all restrictions presented in [The Format](#the-format) and [Combination of Weights](#combination-of-weights) must be upheld.
- Each service must likewise supply two python functions for the creator service: `xxxEdgeConversionScheme(row)` and `xxxnodeConversionScheme(row)`. These will be used by the Controller to take into account what data should be created by the Creator Microservice.
  
In the [data_model.py](#data-model-file) you find in quotes an example of the node data that is recieved from a database request, a node object `SwNode`, and a `nodeConversionScheme` translating between the two. This is followed by the same information regarding edges.
  
  
  ### data model file
  data_model.py
  ``` python
    """
      DB: sw601f20_routing, Table: node
      [RealDictRow([('node_id', 1),
                  ('lon', 9.12668762639212),
                  ('lat', 55.7336881175717)]),
  """
  SwNode = {
              "node_id": 0,#int
              "weight": 0.0,#dec
              "data":{
                  "longitude" : 0.0,#dec
                  "latitude" : 0.0000000000000#dec
              },
              "edges": {} #TODO: change list to dictionary
          }

  def SwNodeConversionScheme(row):
      node = {}#SwNode 
      node["node_id"]= row["node_id"]
      node["node_weight"]= 0.0
      node["data"]= {
          "longitude" : row["lon"],
          "latitude" : row["lat"]
      }
      node["edges"]= {} 

      return node

  """
      DB: sw601f20_routing, Table: Edge
      [RealDictRow([('edge_id', 139263),
                  ('edge_basenode', 1),
                  ('distance', 45.83),
                  ('edge_name', 'Ã…stvej'),
                  ('highway', 'residential'),
                  ('maxspeed', ''),
                  ('edge_adj', 548349)]),
  """
  SwEdge = {
              "edge_id":0,#int  
              "to_node_id": 0,#int
              "weight": 0.0,#dec
              "data":{
                  "distance": 0.00,#dec
                  "road_name": "example road",#string                        
                  "road_type": "example roadtype",#string
                  "maxs_peed": 0#int
              }
          }

  def SwEdgeConversionScheme(row):
      edge = {}#SwEdge
      edge["edge_id"]= row["edge_id"]
      edge["to_node_id"]= row["edge_adj"] 
      edge["edge_weight"]= 0.0

      edge["data"]={
          "distance" : row["distance"],
          "road_name" : row["edge_name"],
          "road_type" : row["highway"],#UNDEFINED 
          "max_speed" : row["maxspeed"],#UNDEFINED
      }
      return edge
  ```
When a microservice introduces new data into the TNM, this file needs to be updated to accomodate the new data. `data_model.py` is used for defining the contents of `nodes` and `edges` and a `conversionScheme function` for each node and edge structure. The conversion functions are injected into the adapter by dependency injection when calling adapter.to_json() within the creator service as shown in the following example:
  ```python
  	adapter.to_json(
                node_conversion_scheme = SwNodeConversionScheme,
                edge_conversion_scheme = SwEdgeConversionScheme,
                edges=sw_handler.get_all('edge'),
                nodes=sw_handler.get_all('node')
                )
  ```
>    **!Note that the variable names in the function calls parameters, on the left side of the equal sign, are used within the to_json function and MUST be identical: 
  *node_conversion_scheme,
  edge_conversion_scheme,
  nodes,
  edges***
{.is-warning}

  
### The data Attribute
The data attribute is meant to hold information that the different specific microservices need. But to accomodate limitations in C# it will be not be a dynamic field but constant, so all microservices wil recieve excactly the same data_model object, the different microservices must decide on what data they need, and add the desired data, that is not allready pressent, to the data field. When doing this make sure to update the data_model and create the appropriate ConversionScheme function to convert the specific database dataRows into the TNM. [General Criteria](#general-criteria)

  
  

### Error Handling
Currently, there is a *strict* error handling, Controller Service driven.
What this means is that any microservice in the pipeline is expected to raise an exception when it sees an error, and the Controller is expected to catch it and create a proper response to the end user.

### Integrating a valid service
Too add a new weighter or router service to the transportation pipeline the controller microservice has to be accessed. This is done thorugh the [GitLab](https://daisy-git.cs.aau.dk/astep-2021/group-11/tnm-controller) of the controller microservice. In the function called `SetupServiceObjects()` inside the `service.py` file four lists are maintained of all the weighter and router services currently accesable for the controller. To integrate a new service add the name and URL of said service to either the weighter or router lists depending on the service. After this has been done and pushed onto the master branch where it hopefully passes the pipeline, you should be able to see your newly added service in the dropdown menues of the TNM service on aSTEP.
Below a code snippet with the four mentioned lists can be seen:
```python
  weighterNames = ["Time To Traverse Road", "Traffic On Road", "Fuel consumption"]	
	weighterURLs = ["URL1", "URL2", "URL3"]
	routerNames = ["A* Router", "Greedy Router", "Deep Q Network Router"]
	routerURLs = ["URL4", "URL5", "URL6"]
``` 
  
## Example
This example shows a star junction.
![star_junction.png](/star_junction.png)

the corresponding TNM model:
```json
{
    "error_list": [],
    "meta_data": {
        "last_service": "Creator",
        "priority": 0
    },
    "vehicle":{
        "id":0,
        "data":{}
    },
    "nodes": {
       "0": {
            "node_id": 0,
            "node_weight": 0.0,
            "data":{
                "longitude": 40,
                "latitude": 50
            },
            "edges": {
                "0":{
                    "edge_id": 0,
                    "to_node_id": 1,
                    "edge_weight": 0.0,
                    "data":{
                        "road_name": "Street A",
                        "distance": 100,
                        "max_speed": 130,
                        "road_type": "highway"
                    }
                },
               "1": {
                    "edge_id": 1,
                    "to_node_id": 2,
                    "edge_weight": 0.0,
                    "data":{
                        "road_name": "Street B",
                        "distance": 200,
                        "max_speed": 80,
                        "road_type": "residential"

                    }
                },
                "2":{
                    "edge_id": 2,
                    "to_node_id": 3,
                    "edge_weight": 0.0,
                    "data":{
                        "road_name": "Street C",
                        "distance": 300,
                        "max_speed": 50,
                        "road_type": "city"

                    }
                }
            }
        },
        "1":{
            "node_id": 1,
            "node_weight": 0.0,
            "data":{
                "longitude": 41,
                "latitude": 51
            },
            "edges": {
            
               "5": {
                    "edge_id": 5,
                    "to_node_id": 0,
                    "edge_weight": 0.0,
                    "data":{
                        "road_name": "Street A",
                        "distance": 100,
                        "max_speed": 130,
                        "road_type": "highway"

                    }
                }
                
            }
        },
        "2":{
            "node_id": 2,
            "node_weight": 0.0,
            "data":{
                "longitude": 42,
                "latitude": 52
            },
            "edges": {
                
                "4":{
                    "edge_id": 4,
                    "to_node_id": 0,
                    "edge_weight": 0.0,
                    "data":{
                        "road_name": "Street B",
                        "distance": 200,
                        "max_speed": 80,
                        "road_type": "residential"

                    }
                }
                
            }
        },
        "3":{
            "node_id": 3,
            "node_weight": 0.0,
            "data":{
                "longitude": 43,
                "latitude": 53
            },
            "edges": {
                "3":{
                    "edge_id": 3,
                    "to_node_id": 0,
                    "edge_weight": 0.0,
                    "data":{
                        "road_name": "Street C",
                        "distance": 300,
                        "max_speed": 50,
                        "road_type": "city"

                    }
                }
            }
        }
    }
}
```
  
## Alternatives

TO DO