---
title: RFC 0020
description: Transportation Network Model
published: true
date: 2021-11-03T07:36:58.599Z
tags: cooperation, transportation, model
editor: markdown
---

# 0020 - Transportation Network Model
**Pending**

*Proposed: 23. Sep. 2021* | *state: 29. Sep. 2021* | *Last Modification: 29. Sep. 2021*

## Summary

A general model for a traffic network, in which multiple microservices can be connected to it in a specified pipeline, where each microservices has the model as an I/O.
Is primarily structured around a standardised schema which describes the model, and a description of the different types of microservices which can be developed to use the schema.
The Transporation Network is basically a weighted graph, where each node and edge has a weight and some data connected.

## Motivation

A general model for a Transporation Network makes it possible for multiple groups to work together with a unified objective, while still maintaining the autonomous development that each group has.
Each microservice enhances the Transportation Network by itself, while the new microservice can be used in conjunction with all the other microservices, making it highly scaleable.
A concrete example would be a microservice that makes the model with data from the database, then three microservices give different weights depending on environmental driving, traffic and (only) shortest distance, which then by the end is fed into a microservice that finds the shortest path based on weights.

## Details

### The Objective
The objective is to describe a JSON schema which can be used as I/O of all microservices working with Transportation Network Model.

To do this, 7 different topics together form the basis of the Transportation Network Model, which is:
- [Component Diagram](#component-diagram)
- [The Format](#the-format)
- [Combination of Weights](#combination-of-weights)
- [Types of Microservices](#types-of-microservices)
- [The data Attribute](#the-data-attribute)
- [Error Handling](#error-handling)
- [Integrating a valid service](#integrating-a-valid-service)

### Component Diagram
INSERT DIAGRAM WHEN MADE AND GIVE OVERARCHING DESCRIPTION OF WORKFLOW

### The Format
The format of the Transportation Network Model is a JSON model suited for being sent and received via http requests, controlled by the UI Controller. The Trafic Network Model (TNM) is the base model that all microservices should use when handling data.
```json
GET / info
output: {
     "error_list" = [
                            {
                              "service": string,      (name of service registering the error)
                              "node": string          (node id where its wrong, null if not a node error),
                              "description": string,
                            },
                            ...
                    ],
       "meta_data": {
                            "last_service": "Creator",    (string)
                            "priority":0                  (0-1)
                      },
          "vehicle":{
                            "id":0,                       (int)
                            "data":{}
                      },
          "nodes": {
          					3302:{node_id: 3302, 								 (int)
                    			weight:0.0                      (0-1)
                          ...
                          data{}                          (UNDEFINED) 
                          },
                    3301:{node_id: 3301, 
                          weight:0.3
                          ...
                         }
                    ...
                     }
              }

```

In the format, the parenthesis describes if the attribute is constrained to be some specific value or should be inside some range.
Also, the syntax ... signifies that the list can contain an indefinete amount of objects following the given schema.


This design has been chosen, since then all nodes contains each of its edges going outward (the right side of the road), whereas all ingoing edges (roads) are contained in other nodes. This reduces the duplication of data, and also takes into account that sometimes the right side of the road is filled by traffic, while the other side of the road might be completely free.

The details of what the other different attributes mean, is described in the following topics.
- `error_list` is described in [Error Handling](#error-handling)
- `meta_data` and `data` is described in [The data Attribute](#the-data-attribute)
- `weight` is described in [Normalization of Weights](#normalization-of-weights)



In the format, the parenthesis describes if the attribute is constrained to be some specific value or should be inside some range.
Also, the syntax ... signifies that the list can contain an indefinete amount of objects following the given schema.

The `vehicle` object signifies the object being simulated to be on the road.

The `nodes` list/dictionary is a dictionary/list<node> of individual nodes, signifying unique GPS coordinates on a map, typically intersections where roads meet. Each node contains an edges dictionary/list<edge> of directed edges leaving the node. A node represents a junction, the node weight represents the notion that a node can cause a delay when travelling over it. (A node could be a traffic light junction).
```json
Node = {
            "node_id": 1,
            "weight": 1,
            "data":{
                "longitude" : 12.6236419221083,
                "latitude" : 12.6236419221083
            },
            "edges": {3245:{edge_id:3245 ....}}
        }
```

The `edges` is a list<edge> of edges. An edge represents a road segment from a node to a node. Thus the edges list represents all roads leaving the node. 
Note that the from_node is implicitly the node that contains the edge, and the to_node_id is the endpoint of the roadsegment. 
```json
Edge = {
            "edge_id":9,  
            "to_node_id": 2,
            "weight": 1,
            "data":{
                "distance": 45.83,
                "road_name": "Ã…stvej",                        
                "road_type": "residential",
                "maxs_peed": 60
            }
        }
```

Data: The `data` field contained in `node`, `edge`, `vehicle` can hold any kind of data, thus it can be used if a microservice handles data specific to a certain microservice. the examples above places locational data and speed limits in the data field. If a microservice wants to handle new kinds of date, they need to update the `data_model` with a conversionScheme function.


Example: 
this example shows a star junction.
![star_junction.png](/star_junction.png)

the corresponding TNM model:
```json
{
    "error_list": [],
    "meta_data": {
        "last_service": "Creator",
        "priority": 0
    },
    "vehicle":{
        "id":0,
        "data":{}
    },
    "nodes": {
       "0": {
            "node_id": 0,
            "node_weight": 0.0,
            "data":{
                "longitude": 40,
                "latitude": 50
            },
            "edges": {
                "0":{
                    "edge_id": 0,
                    "to_node_id": 1,
                    "edge_weight": 0.0,
                    "data":{
                        "road_name": "Street A",
                        "distance": 100,
                        "max_speed": 130,
                        "road_type": "highway"
                    }
                },
               "1": {
                    "edge_id": 1,
                    "to_node_id": 2,
                    "edge_weight": 0.0,
                    "data":{
                        "road_name": "Street B",
                        "distance": 200,
                        "max_speed": 80,
                        "road_type": "residential"

                    }
                },
                "2":{
                    "edge_id": 2,
                    "to_node_id": 3,
                    "edge_weight": 0.0,
                    "data":{
                        "road_name": "Street C",
                        "distance": 300,
                        "max_speed": 50,
                        "road_type": "city"

                    }
                }
            }
        },
        "1":{
            "node_id": 1,
            "node_weight": 0.0,
            "data":{
                "longitude": 41,
                "latitude": 51
            },
            "edges": {
            
               "5": {
                    "edge_id": 5,
                    "to_node_id": 0,
                    "edge_weight": 0.0,
                    "data":{
                        "road_name": "Street A",
                        "distance": 100,
                        "max_speed": 130,
                        "road_type": "highway"

                    }
                }
                
            }
        },
        "2":{
            "node_id": 2,
            "node_weight": 0.0,
            "data":{
                "longitude": 42,
                "latitude": 52
            },
            "edges": {
                
                "4":{
                    "edge_id": 4,
                    "to_node_id": 0,
                    "edge_weight": 0.0,
                    "data":{
                        "road_name": "Street B",
                        "distance": 200,
                        "max_speed": 80,
                        "road_type": "residential"

                    }
                }
                
            }
        },
        "3":{
            "node_id": 3,
            "node_weight": 0.0,
            "data":{
                "longitude": 43,
                "latitude": 53
            },
            "edges": {
                "3":{
                    "edge_id": 3,
                    "to_node_id": 0,
                    "edge_weight": 0.0,
                    "data":{
                        "road_name": "Street C",
                        "distance": 300,
                        "max_speed": 50,
                        "road_type": "city"

                    }
                }
            }
        }
    }
}
```
### Combination of Weights
  Work in progess
  In this section the combination of weights done by the combiner will be explained, the data within the models will be combined into one model. For more information check [WeightCombiner](https://daisy-git.cs.aau.dk/astep-2021/astep-6/-/wikis/home).
  
  ##### Calculation of combined weights
  Weights for both nodes and edges are calculated with the following equation:
  
  $$W_{r} = \sum_{i=1}^{n}W_{i}P_{i}$$
  
  Where $W_{r}$ is the combined weight of $n$ models, combination is done by taking the sum of multiplying the specific weight of model $W_{i}$ and the priority of the that model $P_{i}$ for each model.
  
  Where the following must hold to get a correct answer.
  
  1. $$0 \le W_{x} \le 1$$
  2. $$0 \le P_{x} \le 1$$
  3. $$1 = \sum_{i = 1}^{n} P_{i}$$
  
  If these does not hold, then the microservice may give errors or combine the models incorrecly.
  
### Types of Microservices
Each microservice that wants to abide to the Transport Network Model interface has to uphold some general criteria and some specific criteria, based on which type of microservice it is, abiding by the rule that a microservice must do only one thing, but do it well.

The (current) different types of microservices are.
- `Creator`:
  The Creator handles database access, it converts database data into the TNM model. To gain database access, you will need to have the `database.ini` file in the creator src repo, this file holds the credentials to the database and should be kept in the gitignore file. 
  The Creator contains the definition of the `data_model.py`(TNM) , and an `adaptor.py` file that handles the conversion from database rows to the TNM. 
- `Trimmer`:
  
- `Expector`:
  
- `Weighter`:
  
- `Combiner`:
  A Combiner is a microservice that combines multiple TNMs into one, and normalizes the weights while keeping the priorizations made by the user. A concrete implementation of this is the [TNMCombinerWeightCombiner2021](https://daisy-git.cs.aau.dk/astep-2021/astep-6) service on the gitLab server.
  
- `Router`:
  

At the end of this section, there is detailed how new types of microservices can be added to the UI controller which calls the different microservices.

#### General Criteria
These are the criteria all valid microservices must use, who wants to use this Transportation Network Model.
- Each service must either supply two python functions for the creator service: `xxxEdgeConversionScheme(row)` and `xxxnodeConversionScheme(row)` then call the Creator microservice to get the desired data passing these functions together with the params. Or each microservice must implement an Adapter inside the service, which has two functions, to_json(internal_rep) and from_json(model_schema) (naming may also be camelCase or PascalCase dependent on implementation language).
- from_json(model_schema) should be the first process run by the service, which deserializes the model_schema, which it receives from the UI Controller when called, into some internal representation (internal_rep)
- to_json() should be the last process run by the service before returning the model back to the UI Controller, which seriailizes the internal representation into a valid Transportation Network Model schema.
- The internal representation may be as different and chaotic as necessary, but when serialized into a valid schema, all restrictions presented in [The Format](#the-format) and [Normalization of Weights](#normalization-of-weights) must be upheld.
An example of a conversionScheme function is shown below:
  ``` python
    """
      DB: sw601f20_routing, Table: node
      [RealDictRow([('node_id', 1),
                  ('lon', 9.12668762639212),
                  ('lat', 55.7336881175717)]),
  """
  SwNode = {
              "node_id": 0,#int
              "weight": 0.0,#dec
              "data":{
                  "longitude" : 0.0,#dec
                  "latitude" : 0.0000000000000#dec
              },
              "edges": {} #TODO: change list to dictionary
          }

  def SwNodeConversionScheme(row):
      node = {}#SwNode 
      node["node_id"]= row["node_id"]
      node["node_weight"]= 0.0
      node["data"]= {
          "longitude" : row["lon"],
          "latitude" : row["lat"]
      }
      node["edges"]= {} 

      return node

  """
      DB: sw601f20_routing, Table: Edge
      [RealDictRow([('edge_id', 139263),
                  ('edge_basenode', 1),
                  ('distance', 45.83),
                  ('edge_name', 'Ã…stvej'),
                  ('highway', 'residential'),
                  ('maxspeed', ''),
                  ('edge_adj', 548349)]),
  """
  SwEdge = {
              "edge_id":0,#int  
              "to_node_id": 0,#int
              "weight": 0.0,#dec
              "data":{
                  "distance": 0.00,#dec
                  "road_name": "example road",#string                        
                  "road_type": "example roadtype",#string
                  "maxs_peed": 0#int
              }
          }

  def SwEdgeConversionScheme(row):
      edge = {}#SwEdge
      edge["edge_id"]= row["edge_id"]
      edge["to_node_id"]= row["edge_adj"] 
      edge["edge_weight"]= 0.0

      edge["data"]={
          "distance" : row["distance"],
          "road_name" : row["edge_name"],
          "road_type" : row["highway"],#UNDEFINED 
          "max_speed" : row["maxspeed"],#UNDEFINED
      }
      return edge
  ```

### The data Attribute
  The data attribute is meant to hold information that the different specific microservices need. But to accomodate limitations in C# it will be not be a dynamic field but constant, so all microservices wil recieve excactly the same data_model object, the different microservices must decide on what data they need, and add the desired data, that is not allready pressent, to the data field. When doing this make sure to update the data_model and create the appropriate ConversionScheme function to convert the specific database dataRows into the TNM.
see: - [General Criteria](#General Criteria)

  
  

### Error Handling
TO DO WHEN STANDARDISED
Current suggestion: List of error objects, where an error object contains what microservice created the error, and a description of what the error is.

### Integrating a valid service
TO DO BY CONTROLLER GROUP

## Alternatives

TO DO